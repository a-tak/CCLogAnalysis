# 初期スキャン非同期化実装プラン

## 目的

サーバー起動時の初期スキャンを非同期化し、大量のセッションファイルがある場合でもWebサーバーを即座に起動できるようにする。

## 背景

### 現状の問題

- `cmd/server/main.go:59-65` で `db.SyncAll()` がブロッキング実行
- スキャン完了を待ってからWebサーバーが起動（行100）
- 大量のセッションファイルがある場合、起動に時間がかかる
- ユーザーはスキャン完了まで何も操作できない

### 解決方針

1. **スキャン状態管理マネージャー**を導入
2. スキャンを**goroutineで非同期実行**
3. **APIエンドポイント**でスキャン状況を提供
4. **フロントエンド**でスキャン進行中インジケーター表示

---

## 実装計画

### Phase 1: バックエンド基盤（優先度: 最高）

#### 1.1 新規作成: `internal/scanner/manager.go`

スキャン処理の状態管理とライフサイクル制御を担当。

**主要な型定義**:

```go
type ScanStatus string

const (
    ScanStatusIdle       ScanStatus = "idle"       // スキャン未実行
    ScanStatusRunning    ScanStatus = "running"    // スキャン実行中
    ScanStatusCompleted  ScanStatus = "completed"  // スキャン完了
    ScanStatusFailed     ScanStatus = "failed"     // スキャン失敗
)

type ScanProgress struct {
    Status            ScanStatus
    ProjectsProcessed int
    SessionsFound     int
    SessionsSynced    int
    ErrorCount        int
    StartedAt         time.Time
    CompletedAt       *time.Time
    LastError         string
}

type ScanManager struct {
    db       *db.DB
    parser   *parser.Parser
    progress *ScanProgress
    mu       sync.RWMutex
    cancelFn context.CancelFunc
    wg       sync.WaitGroup
}
```

**主要なメソッド**:

- `NewScanManager(db *db.DB, parser *parser.Parser) *ScanManager`
- `StartInitialScan(ctx context.Context) error` - 非同期でスキャン開始
- `GetProgress() ScanProgress` - 現在の進捗状況を取得（スレッドセーフ）
- `Stop()` - スキャン処理を停止

**実装の詳細**:

- `StartInitialScan`はgoroutineでスキャンを開始し、即座にリターン
- `sync.RWMutex`でスレッドセーフな状態管理
- `context.Context`でキャンセル可能に
- スキャン中に`SyncResult`の進捗を`ScanProgress`に反映

#### 1.2 新規作成: `internal/scanner/manager_test.go`

**テスト項目**:

- [ ] スキャン状態遷移のテスト（idle → running → completed）
- [ ] エラー時の状態遷移（idle → running → failed）
- [ ] 同時アクセス時のスレッドセーフ性テスト
- [ ] キャンセル処理のテスト（Stop呼び出し）
- [ ] 進捗情報の更新テスト

#### 1.3 修正: `cmd/server/main.go`

**変更内容**:

1. **ScanManagerの初期化**（55-68行を置き換え）

```go
// ScanManagerを作成
scanManager := scanner.NewScanManager(database, p)

// スキャンを非同期で開始（ブロックしない）
skipInitialSync := os.Getenv("SKIP_INITIAL_SYNC") != ""
if !skipInitialSync {
    if err := scanManager.StartInitialScan(context.Background()); err != nil {
        log.Printf("Warning: Failed to start initial scan: %v", err)
    }
    fmt.Println("Initial sync started in background...")
} else {
    fmt.Println("Skipping initial sync (SKIP_INITIAL_SYNC is set)")
}
```

2. **ScanManagerをHandlerに渡す**（90行を修正）

```go
handler := api.NewHandler(service, scanManager)
```

3. **Graceful Shutdown対応**（110-120行を拡張）

```go
case <-sigCh:
    fmt.Println("\nShutting down gracefully...")

    // スキャンマネージャーを停止
    if scanManager != nil {
        scanManager.Stop()
    }

    // ファイルウォッチャーを停止
    if fileWatcher != nil {
        fileWatcher.Stop()
    }

    // データベースをクローズ
    database.Close()
```

#### 1.4 修正: `internal/api/service_db.go`

**変更内容**:

- `autoSyncIfNeeded()`の呼び出しを**削除**または**無効化**
  - 理由: ScanManagerで初期スキャンを管理するため、重複を避ける
  - 行30-33を削除または条件分岐で無効化

---

### Phase 2: API実装（優先度: 高）

#### 2.1 新規作成: `internal/api/handlers_scan.go`

スキャン状態APIハンドラー。

**APIレスポンス型**:

```go
type ScanStatusResponse struct {
    Status            string  `json:"status"`
    ProjectsProcessed int     `json:"projectsProcessed"`
    SessionsFound     int     `json:"sessionsFound"`
    SessionsSynced    int     `json:"sessionsSynced"`
    ErrorCount        int     `json:"errorCount"`
    StartedAt         string  `json:"startedAt"`
    CompletedAt       *string `json:"completedAt,omitempty"`
    LastError         string  `json:"lastError,omitempty"`
}
```

**ハンドラー実装**:

```go
func (h *Handler) getScanStatusHandler(w http.ResponseWriter, r *http.Request) {
    if h.scanManager == nil {
        w.WriteHeader(http.StatusNotImplemented)
        json.NewEncoder(w).Encode(ErrorResponse{
            Error:   "not_available",
            Message: "Scan manager not available",
        })
        return
    }

    progress := h.scanManager.GetProgress()

    var completedAt *string
    if progress.CompletedAt != nil {
        t := progress.CompletedAt.Format(time.RFC3339)
        completedAt = &t
    }

    response := ScanStatusResponse{
        Status:            string(progress.Status),
        ProjectsProcessed: progress.ProjectsProcessed,
        SessionsFound:     progress.SessionsFound,
        SessionsSynced:    progress.SessionsSynced,
        ErrorCount:        progress.ErrorCount,
        StartedAt:         progress.StartedAt.Format(time.RFC3339),
        CompletedAt:       completedAt,
        LastError:         progress.LastError,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}
```

#### 2.2 修正: `internal/api/router.go`

**変更内容**:

1. **Handler構造体に追加**（16-19行を拡張）

```go
type Handler struct {
    service      SessionService
    dbService    *DatabaseSessionService
    scanManager  *scanner.ScanManager  // 追加
}
```

2. **NewHandlerシグネチャ変更**（22-33行を修正）

```go
func NewHandler(service SessionService, scanManager *scanner.ScanManager) *Handler {
    var dbService *DatabaseSessionService
    if dbs, ok := service.(*DatabaseSessionService); ok {
        dbService = dbs
    }

    return &Handler{
        service:     service,
        dbService:   dbService,
        scanManager: scanManager,  // 追加
    }
}
```

3. **新規エンドポイント追加**（127行の後に追加）

```go
// Scan status endpoint
mux.HandleFunc("GET /api/scan/status", h.getScanStatusHandler)
```

#### 2.3 修正: `internal/api/types.go`

**追加内容**:

```go
// ScanStatusResponse represents the scan status
type ScanStatusResponse struct {
    Status            string  `json:"status"`
    ProjectsProcessed int     `json:"projectsProcessed"`
    SessionsFound     int     `json:"sessionsFound"`
    SessionsSynced    int     `json:"sessionsSynced"`
    ErrorCount        int     `json:"errorCount"`
    StartedAt         string  `json:"startedAt"`
    CompletedAt       *string `json:"completedAt,omitempty"`
    LastError         string  `json:"lastError,omitempty"`
}
```

---

### Phase 3: フロントエンド実装（優先度: 高）

#### 3.1 修正: `web/src/lib/api/types.ts`

**追加内容**:

```typescript
export interface ScanStatus {
  status: 'idle' | 'running' | 'completed' | 'failed'
  projectsProcessed: number
  sessionsFound: number
  sessionsSynced: number
  errorCount: number
  startedAt: string
  completedAt?: string
  lastError?: string
}
```

#### 3.2 修正: `web/src/lib/api/client.ts`

**追加内容**:

```typescript
// Get scan status
async getScanStatus(): Promise<ScanStatus> {
  return fetchApi<ScanStatus>('/scan/status')
}
```

#### 3.3 新規作成: `web/src/components/scan/ScanStatusIndicator.tsx`

スキャン進行中インジケーターの表示。

**実装概要**:

- スキャン状態を2秒ごとにポーリング
- スキャン実行中（status: 'running'）の場合のみ表示
- スキャン完了後は自動的に非表示
- 画面右下に固定表示（fixed positioning）

**表示内容**:

- スキナー（アニメーション）
- 「初期スキャン実行中...」
- 進捗状況（sessionsSynced / sessionsFound）

#### 3.4 修正: `web/src/components/layout/Layout.tsx`

**変更内容**:

```typescript
import { ScanStatusIndicator } from '@/components/scan/ScanStatusIndicator'

export function Layout() {
  return (
    <>
      {/* 既存のレイアウト */}
      <div className="min-h-screen">
        {/* ... */}
      </div>

      {/* スキャン状態インジケーター */}
      <ScanStatusIndicator />
    </>
  )
}
```

---

## テスト方法

### 単体テスト

**バックエンド**:

```bash
# ScanManagerのテスト
go test ./internal/scanner/...

# API Handlerのテスト
go test ./internal/api/...
```

### 手動テスト

#### 1. 起動速度の確認

```bash
# サーバー起動
make run-dev

# 起動メッセージを確認
# 期待される出力:
# "Initial sync started in background..."
# "Server starting on http://localhost:8080"
```

- Webサーバーが即座に起動することを確認
- スキャン完了を待たずにブラウザアクセス可能

#### 2. スキャン状態APIの確認

```bash
# スキャン状態を確認
curl http://localhost:8080/api/scan/status

# 期待される出力例（スキャン中）:
# {
#   "status": "running",
#   "projectsProcessed": 2,
#   "sessionsFound": 150,
#   "sessionsSynced": 50,
#   "errorCount": 0,
#   "startedAt": "2026-01-25T10:00:00Z"
# }
```

#### 3. フロントエンドでの表示確認

- ブラウザで `http://localhost:8080` にアクセス
- 画面右下にスキャン進行中インジケーターが表示されることを確認
- スキャン完了後にインジケーターが消えることを確認

#### 4. Graceful Shutdownテスト

```bash
# サーバー起動
make run-dev

# スキャン中に Ctrl+C で終了
# エラーなく終了することを確認
```

#### 5. 部分的なデータ表示テスト

- スキャン実行中にプロジェクト一覧にアクセス
- 既に同期済みのデータが表示されることを確認
- スキャン完了後、新しいセッションが追加されることを確認

---

## エラーハンドリング

### スキャン失敗時の対応

- スキャン失敗時でもWebサーバーは稼働継続
- エラーメッセージをログに出力
- API経由でエラー状態を取得可能（`status: "failed"`, `lastError`）
- フロントエンドでエラー通知を表示（将来拡張）

### 既存機能への影響

- **ファイルウォッチャー**: 影響なし（独立した機能として動作）
- **手動同期**: `/api/debug/sync` は既存通り動作
- **データベース読み取り**: スキャン中でも読み取り可能

---

## 重要な変更点まとめ

### 変更が必要なファイル

1. **cmd/server/main.go** - 既存のブロッキングスキャンを非同期化
2. **internal/api/router.go** - ScanManagerをHandlerに追加
3. **internal/api/service_db.go** - autoSyncIfNeededを無効化
4. **web/src/components/layout/Layout.tsx** - ScanStatusIndicatorを追加

### 新規作成が必要なファイル

1. **internal/scanner/manager.go** - スキャン状態管理の中核
2. **internal/scanner/manager_test.go** - ScanManagerのテスト
3. **internal/api/handlers_scan.go** - スキャン状態APIエンドポイント
4. **web/src/components/scan/ScanStatusIndicator.tsx** - フロントエンドUI

---

## 非機能要件

### パフォーマンス

- スキャン実行中でもWebサーバーは高速応答
- スキャン状態APIのレスポンスタイム: < 10ms
- フロントエンドのポーリング間隔: 2秒

### 信頼性

- スキャン失敗時でもサーバーは稼働継続
- スレッドセーフな状態管理（sync.RWMutex使用）
- Graceful Shutdownでスキャン処理も適切に終了

### 保守性

- スキャンロジックの分離（既存の `db.SyncAll` を再利用）
- テストコードの充実
- 明確な責務分離（ScanManager / Handler / Service）

---

## 将来の拡張性（Phase 2以降）

今回の実装では含めないが、将来的に追加可能な機能：

1. **スキャン進捗のパーセンテージ表示**
2. **スキャンのキャンセル機能**（UIから停止可能）
3. **スキャン完了通知**（ブラウザ通知API）
4. **増分スキャンの最適化**（ファイル更新日時チェック）
5. **スキャン履歴の記録**（データベースに保存）

---

## 検証基準

以下を全て満たすこと：

- [ ] サーバー起動が即座に完了する（スキャン待機なし）
- [ ] `/api/scan/status` でスキャン状態が取得できる
- [ ] フロントエンドでスキャン進行中インジケーターが表示される
- [ ] スキャン完了後、インジケーターが消える
- [ ] スキャン中でもプロジェクト一覧が表示できる
- [ ] 全ての単体テストがパスする
- [ ] Graceful Shutdownが正常に動作する
- [ ] スキャン失敗時でもサーバーは稼働継続する
