# ワークツリー監視修正プラン

## 📋 Issue情報

- **Issue番号**: #9
- **タイトル**: ワークツリーのセッションログがバックエンド監視対象外
- **状態**: OPEN

## 🎯 問題の概要

**現象:**
- メインリポジトリ: ✅ 正常に監視され、ログがフロントエンドに反映される
- ワークツリー: ❌ 監視対象外で、ログが反映されない

**根本原因:**
増分同期（`SyncIncremental`）が新規プロジェクト作成時にGit Root検出を実行しないため、ワークツリーのセッションが正しくグループ化されない。

## 🔍 調査結果

### 既存実装の動作

1. **初期同期（SyncAll）**: ✅ 正常動作
   - `syncProjectInternalWithLogger()` (sync.go:414-436) でGit Root検出
   - 新規プロジェクト作成時に `CreateProjectWithGitRoot()` を呼び出し
   - 既存プロジェクトでも `git_root == NULL` の場合は検出・更新（sync.go:456-487）
   - 10プロジェクトごとに `SyncProjectGroups()` を呼び出し

2. **増分同期（SyncIncremental）**: ❌ 問題あり
   - 新規プロジェクト作成時に `CreateProject()` を使用（sync.go:242）
   - **Git Root検出を実行しない**
   - **`SyncProjectGroups()` を呼び出さない**

3. **ファイル監視（FileWatcher）**
   - 15秒ポーリングで `SyncIncremental()` を呼び出し
   - 新規ワークツリーが検出されてもGit Rootが設定されない

### Git Root検出機能

- ✅ `internal/gitutil/gitutil.go` で実装済み
- ✅ ワークツリー対応済み（`.git` ファイルをパースして `gitdir` を抽出）
- ✅ テストカバレッジあり

## 🚀 実装アプローチ

**選択肢1（推奨）: SyncIncrementalに新規プロジェクト検出ロジックを追加**

- 既存の `syncProjectInternalWithLogger()` のロジックを再利用
- パフォーマンス影響が最小（新規プロジェクトのみGit Root検出）
- コードの重複を最小化

## 📝 実装ステップ（TDD）

### Step 1: テスト作成（Red）

**ファイル**: `internal/db/sync_test.go`

**追加するテスト:**

1. `TestSyncIncremental_NewWorktreeProject`
   - 新規ワークツリープロジェクトが増分同期で正しく検出される
   - Git Rootが正しく設定される

2. `TestSyncIncremental_NewProjectWithGitRoot`
   - 新規プロジェクト作成時にGit Root検出が実行される
   - `CreateProjectWithGitRoot()` が呼び出される

3. `TestSyncIncremental_ProjectGroupsSync`
   - 新規プロジェクト検出後に `SyncProjectGroups()` が呼び出される
   - プロジェクトグループが正しく構築される

4. `TestSyncIncremental_ExistingProjectNoUpdate`
   - 既存プロジェクトに影響がないことを確認
   - Git Root再検出が実行されない

### Step 2: 実装（Green）

**ファイル**: `internal/db/sync.go`

**修正箇所**: `SyncIncrementalWithLogger()` 関数（行236-262周辺）

**実装内容:**

```go
// 新規プロジェクト検出フラグ
hasNewProjects := false

for _, projectName := range projectNames {
    project, err := database.GetProjectByName(projectName)
    if err != nil {
        // プロジェクトが存在しない場合は作成
        hasNewProjects = true

        decodedPath := parser.DecodeProjectPath(projectName)

        // Git Root検出（syncProjectInternalWithLogger と同じロジック）
        workingDir, err := p.GetProjectWorkingDirectory(projectName)
        if err != nil {
            log.WarnWithContext("Could not get working directory", ...)
            projectID, err = database.CreateProject(projectName, decodedPath)
        } else {
            gitRoot, gitErr := gitutil.DetectGitRoot(workingDir)
            if gitErr != nil {
                log.WarnWithContext("Failed to detect git root", ...)
                projectID, err = database.CreateProject(projectName, decodedPath)
            } else if gitRoot != "" {
                projectID, err = database.CreateProjectWithGitRoot(projectName, decodedPath, gitRoot)
                log.InfoWithContext("Created project with git root", ...)
            } else {
                projectID, err = database.CreateProject(projectName, decodedPath)
            }
        }

        // エラーハンドリング（既存と同じ）
        if err != nil {
            log.ErrorWithContext("Failed to create project", ...)
            result.ErrorCount++
            continue
        }

        // 作成したプロジェクトを取得
        project, err = database.GetProjectByID(projectID)
        if err != nil {
            log.ErrorWithContext("Failed to get created project", ...)
            result.ErrorCount++
            continue
        }
    }

    // ... セッション同期処理（既存のまま）...
}

// 新規プロジェクトが検出された場合のみグループを同期
if hasNewProjects {
    if err := database.SyncProjectGroups(); err != nil {
        log.WarnWithContext("Failed to sync project groups", ...)
    } else {
        log.InfoWithContext("Project groups synchronized after new projects detected", ...)
    }
}
```

**ログ追加:**
- Git Root検出成功時: INFO レベル
- Git Root検出失敗時: WARN レベル
- グループ同期成功時: INFO レベル
- グループ同期失敗時: WARN レベル

### Step 3: リファクタリング（Refactor）

**目的**: コードの重複を削減（オプション）

**実装内容:**
- 新規プロジェクト作成ロジックを共通関数に抽出
- `syncProjectInternalWithLogger()` と `SyncIncrementalWithLogger()` で共有
- 関数名: `createProjectWithDetection(db, parser, projectName, log)`

**判断基準:**
- コードレビュー時に重複が気になる場合に実施
- 実装の複雑性とメリットを比較して判断

### Step 4: 統合テスト

**ファイル**: `internal/watcher/watcher_test.go`（存在しない場合は作成）

**テスト内容:**

1. `TestFileWatcher_DetectsNewWorktree`
   - ファイル監視が新規ワークツリーを検出
   - 増分同期がトリガーされる
   - Git Rootが正しく設定される
   - プロジェクトグループが更新される

### Step 5: エッジケーステスト

**追加テスト:**

1. Git Root検出失敗時の挙動（フォールバック確認）
2. 複数ワークツリーの同時追加
3. `.git` ファイルが不正な形式の場合
4. 作業ディレクトリ取得失敗時の挙動

## 🔧 変更ファイル

### 必須変更

1. **`internal/db/sync.go`**
   - `SyncIncrementalWithLogger()` 関数を修正
   - 新規プロジェクト作成時にGit Root検出を追加
   - 新規プロジェクト検出時に `SyncProjectGroups()` を呼び出し

2. **`internal/db/sync_test.go`**
   - 新規ワークツリー検出のテストを追加
   - 既存プロジェクト影響なしのテストを追加

### オプション変更

3. **`internal/watcher/watcher_test.go`**（新規作成）
   - 統合テストを追加

## ⚡ パフォーマンス影響

### 計算量分析

**変更前:**
- 計算量: O(N × セッション数)

**変更後:**
- 新規プロジェクト数: M（M << N）
- 計算量: O(N × セッション数 + M × Git検出) + O(グループ同期)
- Git検出: ファイル読み取り1回 + パス解析（O(1)）
- グループ同期: O(N)（全プロジェクトをスキャン）

**影響評価:**
- 新規プロジェクトがない場合（通常）: 影響なし
- 新規プロジェクトがある場合: ほぼ無視できる影響
- 15秒ポーリング間隔で、新規プロジェクト作成は稀なため、実質的な影響は最小

## 🧪 テスト計画（検証手順）

### 1. ユニットテスト

```bash
# 全テストを実行
go test ./internal/db/... -v

# sync_test.go のみ実行
go test ./internal/db/ -run TestSyncIncremental -v
```

**確認項目:**
- [ ] 新規ワークツリープロジェクトがGit Rootとともに作成される
- [ ] プロジェクトグループが正しく構築される
- [ ] 既存プロジェクトに影響がない

### 2. 統合テスト（手動）

**準備:**
1. サーバーを起動: `/server-management start dev`
2. フロントエンドにアクセス: `http://localhost:3000`

**テストケース1: メインリポジトリ**
1. メインリポジトリで Claude Code セッションを実行
2. 15秒待機
3. フロントエンドでセッションが表示されることを確認

**テストケース2: 新規ワークツリー**
1. 新しいワークツリーを作成: `git worktree add ../test-worktree feature-branch`
2. ワークツリーで Claude Code セッションを実行
3. 15秒待機
4. **フロントエンドでセッションが表示されることを確認**
5. **プロジェクトグループが正しく表示されることを確認**

**テストケース3: 既存ワークツリー**
1. 既存ワークツリーで Claude Code セッションを実行
2. 15秒待機
3. セッションが即座に表示されることを確認

### 3. ログ確認

```bash
# サーバーログを確認
tail -f /tmp/ccloganalysis-server.log
```

**期待されるログ:**
```
[INFO] Created project with git root: project_name=/path/to/worktree git_root=/path/to/repo
[INFO] Project groups synchronized after new projects detected
```

### 4. データベース確認

```bash
# プロジェクト一覧を確認
sqlite3 ~/.ccloganalysis/ccloganalysis.db "SELECT name, decoded_path, git_root FROM projects WHERE git_root IS NOT NULL;"

# プロジェクトグループを確認
sqlite3 ~/.ccloganalysis/ccloganalysis.db "SELECT * FROM project_groups;"
```

**期待される結果:**
- ワークツリープロジェクトに `git_root` が設定されている
- 同じ `git_root` を持つプロジェクトが同じグループに属している

## ✅ 完成条件

- [ ] 全ユニットテストがパス
- [ ] 新規ワークツリーがファイル監視で正しく検出される
- [ ] Git Rootが正しく設定される
- [ ] プロジェクトグループが正しく構築される
- [ ] 既存のSyncAll動作に影響がない
- [ ] パフォーマンス劣化がない（15秒ポーリングで問題なし）
- [ ] エラーログが適切に出力される
- [ ] 手動テストで動作確認完了

## 📦 コミット戦略

```bash
# Commit 1: テスト追加
git add internal/db/sync_test.go
git commit -m "test: 増分同期での新規ワークツリー検出テストを追加

Issue #9 の修正に向けて、SyncIncremental が新規ワークツリー
プロジェクトを検出し、Git Root を正しく設定することを確認する
テストを追加。

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Commit 2: 機能実装
git add internal/db/sync.go
git commit -m "feat: 増分同期で新規プロジェクトのGit Root検出を実装

SyncIncremental が新規プロジェクトを検出した際に、Git Root を
検出してプロジェクトグループを自動的に同期するように修正。
これにより、ワークツリーのセッションログも正しくグループ化される。

主な変更:
- 新規プロジェクト作成時に Git Root 検出を実行
- Git Root 設定に成功した場合、CreateProjectWithGitRoot を使用
- 新規プロジェクト検出後に SyncProjectGroups を呼び出し

Fixes #9

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Commit 3 (オプション): リファクタリング
git add internal/db/sync.go
git commit -m "refactor: プロジェクト作成ロジックを共通化

syncProjectInternalWithLogger と SyncIncrementalWithLogger で
重複していたプロジェクト作成ロジックを共通関数に抽出。

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Commit 4 (オプション): 統合テスト
git add internal/watcher/watcher_test.go
git commit -m "test: ファイル監視の統合テストを追加

ファイル監視が新規ワークツリーを検出し、正しく Git Root を
設定することを確認する統合テストを追加。

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
```

## 🎯 重要なファイル

- **`internal/db/sync.go`** (行236-262): SyncIncremental修正箇所
- **`internal/db/sync.go`** (行414-487): 参考実装（syncProjectInternalWithLogger）
- **`internal/db/sync_test.go`**: テスト追加箇所
- **`internal/gitutil/gitutil.go`**: Git Root検出（既存実装、参照のみ）
- **`internal/db/grouping.go`**: SyncProjectGroups（既存実装、参照のみ）

## 📚 関連情報

- PR #8: ファイルのリアルタイム監視フロントエンド実装
- ファイル監視機能: 15秒ポーリングで正常動作中
- フロントエンドの `usePolling` フック: 正常に実装済み
