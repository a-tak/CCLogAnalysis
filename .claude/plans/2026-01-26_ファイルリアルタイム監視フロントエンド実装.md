# ファイルリアルタイム監視フロントエンド実装プラン

## 📋 概要

**Issue**: #4 - ファイルのリアルタイム監視がされていない

**問題の本質**:
- **バックエンド**: ✅ 15秒ごとのファイル監視機能は完全に実装されており、正常に動作している
- **フロントエンド**: ❌ 定期的なデータ取得（ポーリング）が実装されていないため、画面が自動更新されない

つまり、バックエンドは新しいデータをDBに保存しているのに、フロントエンドがそれを取得していない状況です。

## 🎯 目標

フロントエンドに15秒ごとの自動更新機能（ポーリング）を実装し、バックエンドのファイル監視機能と連携させる。

## 🔍 調査結果サマリー

### バックエンドの状況
- `/internal/watcher/watcher.go` でファイル監視機能が完全に実装済み
- 15秒ごとにポーリングしてファイル変更を検知
- `db.SyncIncremental()` で差分同期を実行
- デバウンス機能、Graceful shutdown 対応済み
- テスト実装済み（20 テスト全 PASS）

### フロントエンドの問題点
以下のページで自動更新機能がない：

| ページ | 現状 | 問題 |
|--------|------|------|
| ProjectsPage | 初回 + period変更時のみデータ取得 | 新規セッション追加後、手動リロードが必要 |
| ProjectDetailPage | 初回 + period変更時のみデータ取得 | グラフや統計が更新されない |
| SessionsPage | 初回 + projectName変更時のみデータ取得 | セッション一覧が自動更新されない |

## 🏗️ 実装アプローチ

### カスタムフック方式を採用

**理由**:
- 同じポーリングロジックを3ページで共有できる
- ポーリング間隔変更時に1箇所修正で対応可能
- フックを独立してテストできる
- データ取得ロジックとUI表示ロジックを分離できる

### 実装する主要コンポーネント

1. **`usePolling` フック** - 汎用ポーリング機能
2. **`useProjectsPolling` フック** - ProjectsPage専用
3. **`useProjectDetailPolling` フック** - ProjectDetailPage専用
4. **`useSessionsPolling` フック** - SessionsPage専用

## 📝 実装手順（TDD準拠）

### Phase 1: テスト環境セットアップ

#### タスク
1. テストライブラリのインストール
   ```bash
   npm install -D @testing-library/react @testing-library/jest-dom @testing-library/user-event vitest jsdom
   ```

2. Vitest設定ファイル作成（`web/vitest.config.ts`）

3. テストヘルパー作成（`web/src/test/setup.ts`）

#### 成果物
- テスト実行環境の構築
- `npm test` でテスト実行可能

#### 優先度
P0（必須）

---

### Phase 2: `usePolling` フック実装（TDD）

#### Step 1: RED - テストを書く

**ファイル**: `web/src/hooks/usePolling.test.ts`

```typescript
describe('usePolling', () => {
  test('初回マウント時に即座にcallbackを実行する')
  test('指定間隔でcallbackを繰り返し実行する')
  test('アンマウント時にタイマーをクリアする')
  test('enabled=falseの場合、ポーリングしない')
  test('enabledがfalse→trueに変化したら、ポーリング開始')
  test('依存配列が変化したら、タイマーを再セットアップ')
  test('callbackがエラーを投げても、次回ポーリングは継続')
})
```

#### Step 2: GREEN - 最小実装

**ファイル**: `web/src/hooks/usePolling.ts`

```typescript
export function usePolling(
  callback: () => void | Promise<void>,
  interval: number,
  enabled: boolean = true
) {
  useEffect(() => {
    if (!enabled) return

    // 初回実行
    callback()

    // 定期実行
    const intervalId = window.setInterval(callback, interval)

    // クリーンアップ
    return () => {
      clearInterval(intervalId)
    }
  }, [callback, interval, enabled])
}
```

#### Step 3: REFACTOR - 改善

- エラーハンドリングの追加
- `useCallback` での最適化検討
- 型定義の厳密化

#### 成果物
- テスト済み汎用ポーリングフック
- テストカバレッジ100%

#### 優先度
P0（必須）

---

### Phase 3: ページ専用フック実装（TDD）

#### 3.1 `useProjectsPolling` 実装

**テストファイル**: `web/src/hooks/useProjectsPolling.test.ts`

**実装ファイル**: `web/src/hooks/useProjectsPolling.ts`

**機能**:
```typescript
export function useProjectsPolling(period: 'day' | 'week' | 'month') {
  const [projects, setProjects] = useState<Project[]>([])
  const [groups, setGroups] = useState<ProjectGroup[]>([])
  const [totalStats, setTotalStats] = useState<TotalStats | null>(null)
  const [timeline, setTimeline] = useState<TimeSeriesResponse | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchData = useCallback(async () => {
    try {
      setError(null)
      const [projectsRes, groupsRes, statsRes, timelineRes] = await Promise.all([
        api.getProjects(),
        api.getProjectGroups(),
        api.getTotalStats(),
        api.getTotalTimeline(period, 30),
      ])
      setProjects(projectsRes.projects)
      setGroups(groupsRes.groups)
      setTotalStats(statsRes)
      setTimeline(timelineRes)
    } catch (err) {
      setError(err instanceof ApiError ? err.message : 'Failed to load data')
    } finally {
      setLoading(false)
    }
  }, [period])

  usePolling(fetchData, 15000, true)

  return { projects, groups, totalStats, timeline, loading, error }
}
```

**重要な改善点**:
- 初回ローディングと更新を区別（2回目以降は loading を true にしない）
- エラー発生時もポーリング継続

#### 3.2 `useProjectDetailPolling` 実装

同様のTDDサイクルで実装。

#### 3.3 `useSessionsPolling` 実装

同様のTDDサイクルで実装。

#### 成果物
- 3つのページ専用ポーリングフック
- 各フックの単体テスト

#### 優先度
P0（必須）

---

### Phase 4: ページコンポーネント統合

#### 4.1 ProjectsPage リファクタリング

**変更内容**:
```typescript
// Before (29-56行目)
useEffect(() => {
  async function loadData() { ... }
  loadData()
}, [period])

// After
const { projects, groups, totalStats, timeline, loading, error } =
  useProjectsPolling(period)
```

**テスト**:
- 既存の表示ロジックが壊れていないか確認
- ポーリングが実際に動作するか確認

#### 4.2 ProjectDetailPage リファクタリング

同様に統合。

#### 4.3 SessionsPage リファクタリング

同様に統合。

#### 成果物
- ポーリング機能を持つ3ページ
- 統合テスト

#### 優先度
P0（必須）

---

## 🔧 エッジケース処理

### 1. ネットワークエラー

**戦略**:
- エラー発生時もポーリングは継続
- エラーメッセージをユーザーに表示
- 次回ポーリングで自動復旧を試みる

### 2. コンポーネントアンマウント時

**戦略**:
- `useEffect` のクリーンアップ関数で確実にタイマークリア
- メモリリークを防止

### 3. 初回ローディング vs 更新ローディング

**問題**: 15秒ごとにローディングスピナーが表示されるとUX悪化

**戦略**:
- 初回ロード: `loading = true` でスピナー表示
- 2回目以降: `loading = false` のまま、データのみ更新

**実装**:
```typescript
const [isInitialLoad, setIsInitialLoad] = useState(true)

const fetchData = useCallback(async () => {
  try {
    // データ取得
    setIsInitialLoad(false)
  } catch (err) {
    // エラー処理
  } finally {
    if (isInitialLoad) {
      setLoading(false)
    }
  }
}, [isInitialLoad, period])
```

**優先度**: P0（必須、UXに直結）

---

## 📂 重要なファイル

### 新規作成するファイル
- `web/src/hooks/usePolling.ts` - 汎用ポーリングフック
- `web/src/hooks/usePolling.test.ts` - テスト
- `web/src/hooks/useProjectsPolling.ts` - ProjectsPage専用フック
- `web/src/hooks/useProjectsPolling.test.ts` - テスト
- `web/src/hooks/useProjectDetailPolling.ts` - ProjectDetailPage専用フック
- `web/src/hooks/useProjectDetailPolling.test.ts` - テスト
- `web/src/hooks/useSessionsPolling.ts` - SessionsPage専用フック
- `web/src/hooks/useSessionsPolling.test.ts` - テスト
- `web/vitest.config.ts` - Vitest設定
- `web/src/test/setup.ts` - テストヘルパー

### 修正するファイル
- `web/src/pages/ProjectsPage.tsx` - フック統合（29-56行目を置き換え）
- `web/src/pages/ProjectDetailPage.tsx` - フック統合
- `web/src/pages/SessionsPage.tsx` - フック統合

### 参考にするファイル
- `web/src/components/scan/ScanStatusIndicator.tsx` - 既存のポーリング実装パターン
- `web/src/lib/api/client.ts` - API呼び出しロジック

---

## ✅ 検証方法

### 機能テスト

1. **開発サーバー起動**
   ```bash
   /server-management start dev
   ```

2. **ファイルウォッチャー有効化**

   環境変数 `ENABLE_FILE_WATCH=true` が設定されていることを確認

3. **新規ログファイル追加**

   Claude Codeのログディレクトリに新しい `.jsonl` ファイルを配置

4. **フロントエンド確認**
   - ダッシュボードを開く
   - 15秒以内に新しいセッションが表示されることを確認
   - ローディングスピナーが初回のみ表示され、2回目以降は表示されないことを確認
   - ネットワークタブで15秒ごとにAPI呼び出しが発生することを確認

### テスト実行

```bash
cd web
npm test
```

全テストがパスすることを確認。

### パフォーマンステスト

- React DevTools Profiler でレンダリング回数を確認
- 不要な再レンダリングが発生していないことを確認
- CPU使用率が常識的な範囲内であることを確認

---

## 🎯 成功基準

### 機能要件
- [ ] 15秒ごとに各ページでデータが自動更新される
- [ ] 初回ローディングと更新が区別される
- [ ] エラー発生時も適切にメッセージ表示される
- [ ] アンマウント時にタイマーが確実にクリアされる

### 品質要件
- [ ] 全フックの単体テストカバレッジ100%
- [ ] 統合テストで実際のポーリング動作を検証
- [ ] TypeScriptエラー0件
- [ ] ESLint警告0件

### パフォーマンス要件
- [ ] ポーリングによる体感的な遅延がない
- [ ] メモリリークが発生しない
- [ ] CPU使用率が常識的な範囲内

---

## ⚠️ 注意事項

### useEffectの依存配列

**重要**: `callback` を依存配列に含める場合、必ず `useCallback` でメモ化すること。メモ化しないと無限ループの危険性がある。

### ScanStatusIndicatorとの違い

- **ScanStatusIndicator**: 条件付きポーリング（status='running'の時だけ）
- **今回の実装**: 常時ポーリング（ページ表示中は常に最新データ取得）

### TypeScript型安全性

- APIレスポンス型が正しく定義されているか確認
- フックの戻り値の型が明示されているか確認
- `null` と `undefined` の扱いが一貫しているか確認

---

## 📊 実装優先順位

### P0（必須 - 最小限の動作に必要）
1. テスト環境セットアップ
2. `usePolling` フック実装（TDD）
3. `useProjectsPolling` 実装（TDD）
4. ProjectsPage統合
5. 初回/更新ローディングの区別実装

### P1（推奨 - 全ページ対応）
6. `useProjectDetailPolling` 実装（TDD）
7. ProjectDetailPage統合
8. `useSessionsPolling` 実装（TDD）
9. SessionsPage統合

---

## 🔗 関連ドキュメント

- `docs/要件.md` - ファイルシステム監視機能の要件定義
- `docs/WIP/2026-01-24_ファイルシステム監視機能実装.md` - バックエンド実装記録
- `.claude/rules/general.md` - TDD開発ルール
- `.claude/rules/frontend/react.md` - React開発ルール
