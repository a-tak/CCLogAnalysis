# 初期化進捗表示改善プラン

## 問題の概要

初期起動時のスキャン中、フロントエンドの進捗表示が「0/0」のまま変化しない。

### 根本原因

1. `scanner.ScanManager.runScan()` が `db.SyncAll()` を呼び出し
2. `SyncAll()` はすべてのプロジェクトのスキャンが完了するまでブロック
3. `ScanProgress` は完了後に一括更新される
4. フロントエンドが2秒ごとにポーリングしても、0/0しか取得できない

### 現在の動作フロー

```
サーバー起動
  ↓
ScanManager.StartInitialScan() (非同期)
  ↓
ScanProgress = {Status: running, SessionsFound: 0, SessionsSynced: 0}
  ↓
runScan() が db.SyncAll() を実行（ブロッキング）
  ↓
[この間、フロントエンドは0/0を表示] ← 問題箇所
  ↓
SyncAll() 完了
  ↓
ScanProgress を一括更新
  ↓
フロントエンドに反映
```

---

## 解決策：コールバック方式

### 概要

`SyncAll()` にコールバック関数を渡し、プロジェクト処理ごとに進捗を報告する。

### 修正後の動作フロー

```
サーバー起動
  ↓
ScanManager.StartInitialScan() (非同期)
  ↓
ScanProgress = {Status: running, SessionsFound: 0, SessionsSynced: 0}
  ↓
runScan() が db.SyncAll() を実行（コールバック付き）
  ↓
プロジェクト1を処理 → コールバック呼び出し → ScanProgress更新
  ↓
プロジェクト2を処理 → コールバック呼び出し → ScanProgress更新
  ↓
[フロントエンドは2秒ごとに最新の進捗を取得] ← リアルタイム更新
  ↓
SyncAll() 完了
  ↓
ScanProgress = completed
```

---

## 実装手順

### Phase 1: コールバック型定義とSync層の拡張

#### ファイル: `internal/db/sync.go`

**1. コールバック型定義を追加**

```go
// SyncProgressCallback is called during sync to report progress
type SyncProgressCallback func(progress SyncProgressUpdate)

// SyncProgressUpdate represents incremental progress during sync
type SyncProgressUpdate struct {
    ProjectsProcessed int
    SessionsFound     int
    SessionsSynced    int
    ErrorCount        int
}
```

**2. `SyncAll` にコールバック対応版を追加**

```go
// SyncAllWithCallback synchronizes all projects with progress callbacks
func SyncAllWithCallback(db *DB, p *parser.Parser, callback SyncProgressCallback) (*SyncResult, error) {
    return SyncAllWithLoggerAndCallback(db, p, logger.New(), callback)
}

// SyncAllWithLoggerAndCallback synchronizes all projects with custom logger and callbacks
func SyncAllWithLoggerAndCallback(db *DB, p *parser.Parser, log *logger.Logger, callback SyncProgressCallback) (*SyncResult, error) {
    result := &SyncResult{}

    log.Info("Starting SyncAll with callbacks")

    projectNames, err := p.ListProjects()
    if err != nil {
        return nil, fmt.Errorf("failed to list projects: %w", err)
    }

    log.InfoWithContext("Projects found", map[string]interface{}{
        "count": len(projectNames),
    })

    for i, projectName := range projectNames {
        syncResult, err := syncProjectInternalWithLogger(db, p, projectName, log)
        if err != nil {
            errMsg := fmt.Sprintf("%s: %v", projectName, err)
            result.ErrorCount++
            result.Errors = append(result.Errors, errMsg)
            continue
        }

        result.ProjectsProcessed++
        result.SessionsFound += syncResult.SessionsFound
        result.SessionsSynced += syncResult.SessionsSynced
        result.SessionsSkipped += syncResult.SessionsSkipped
        result.ErrorCount += syncResult.ErrorCount
        result.Errors = append(result.Errors, syncResult.Errors...)

        // コールバックで進捗を報告
        if callback != nil {
            callback(SyncProgressUpdate{
                ProjectsProcessed: result.ProjectsProcessed,
                SessionsFound:     result.SessionsFound,
                SessionsSynced:    result.SessionsSynced,
                ErrorCount:        result.ErrorCount,
            })
        }

        // 既存のグループ同期ロジックも保持
        if (i+1)%10 == 0 || i == len(projectNames)-1 {
            if err := db.SyncProjectGroups(); err != nil {
                log.WarnWithContext("Failed to sync project groups during scan", map[string]interface{}{
                    "processed": i + 1,
                    "error":     err.Error(),
                })
            }
        }
    }

    return result, nil
}
```

**3. 既存の`SyncAll`を保持（後方互換性）**

```go
// SyncAll synchronizes all projects (backwards compatible)
func SyncAll(db *DB, p *parser.Parser) (*SyncResult, error) {
    return SyncAllWithCallback(db, p, nil)
}
```

---

### Phase 2: ScanManager の拡張

#### ファイル: `internal/scanner/manager.go`

**`runScan()` メソッドを修正してコールバックを使用**

```go
func (m *ScanManager) runScan(ctx context.Context) {
    defer m.wg.Done()

    // コールバック関数を定義（進捗をリアルタイム更新）
    progressCallback := func(update db.SyncProgressUpdate) {
        m.mu.Lock()
        m.progress.ProjectsProcessed = update.ProjectsProcessed
        m.progress.SessionsFound = update.SessionsFound
        m.progress.SessionsSynced = update.SessionsSynced
        m.progress.ErrorCount = update.ErrorCount
        m.mu.Unlock()
    }

    // コールバック付きでスキャン実行
    result, err := db.SyncAllWithCallback(m.db, m.parser, progressCallback)

    m.mu.Lock()
    defer m.mu.Unlock()

    now := time.Now()

    if err != nil {
        m.progress.Status = ScanStatusFailed
        m.progress.LastError = err.Error()
        m.progress.CompletedAt = &now
        fmt.Printf("Scan failed: %v\n", err)
        return
    }

    // 最終結果を反映（念のため）
    m.progress.Status = ScanStatusCompleted
    m.progress.ProjectsProcessed = result.ProjectsProcessed
    m.progress.SessionsFound = result.SessionsFound
    m.progress.SessionsSynced = result.SessionsSynced
    m.progress.ErrorCount = result.ErrorCount
    m.progress.CompletedAt = &now

    if result.ErrorCount > 0 {
        m.progress.LastError = fmt.Sprintf("%d errors occurred during scan", result.ErrorCount)
    }

    fmt.Printf("Scan completed: %d projects, %d sessions synced\n",
        result.ProjectsProcessed, result.SessionsSynced)
}
```

---

### Phase 3: テスト実装

#### ファイル: `internal/db/sync_test.go`

**コールバック機能のテスト追加**

```go
func TestSyncAllWithCallback(t *testing.T) {
    // テストDBとパーサーを準備
    database := setupTestDB(t)
    p := setupTestParser(t)

    // コールバック呼び出しを記録
    var updates []SyncProgressUpdate
    callback := func(update SyncProgressUpdate) {
        updates = append(updates, update)
    }

    // コールバック付きでスyncAll実行
    result, err := SyncAllWithCallback(database, p, callback)

    // エラーがないことを確認
    if err != nil {
        t.Fatalf("SyncAllWithCallback failed: %v", err)
    }

    // コールバックが呼び出されたことを確認
    if len(updates) == 0 {
        t.Error("Expected callback to be called, but got no updates")
    }

    // 進捗が増加していることを確認
    for i := 1; i < len(updates); i++ {
        if updates[i].ProjectsProcessed <= updates[i-1].ProjectsProcessed {
            t.Errorf("Progress should increase, got %d -> %d",
                updates[i-1].ProjectsProcessed, updates[i].ProjectsProcessed)
        }
    }

    // 最終結果と最後のコールバックが一致することを確認
    lastUpdate := updates[len(updates)-1]
    if lastUpdate.ProjectsProcessed != result.ProjectsProcessed {
        t.Errorf("Last callback ProjectsProcessed=%d, result=%d",
            lastUpdate.ProjectsProcessed, result.ProjectsProcessed)
    }
}

func TestSyncAllWithNilCallback(t *testing.T) {
    // nilコールバックでもエラーが発生しないことを確認
    database := setupTestDB(t)
    p := setupTestParser(t)

    _, err := SyncAllWithCallback(database, p, nil)
    if err != nil {
        t.Fatalf("SyncAllWithCallback with nil callback failed: %v", err)
    }
}
```

#### ファイル: `internal/scanner/manager_test.go`

**ScanManager の進捗更新テスト追加**

```go
func TestScanManagerProgressUpdates(t *testing.T) {
    // モックDBとパーサーを準備
    database := setupTestDB(t)
    p := setupTestParser(t)

    manager := NewScanManager(database, p)

    // スキャン開始
    ctx := context.Background()
    err := manager.StartInitialScan(ctx)
    if err != nil {
        t.Fatalf("Failed to start scan: %v", err)
    }

    // 進捗が更新されるまでポーリング
    timeout := time.After(10 * time.Second)
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    var progressUpdates []ScanProgress
    for {
        select {
        case <-timeout:
            t.Fatal("Timeout waiting for progress updates")
        case <-ticker.C:
            progress := manager.GetProgress()
            progressUpdates = append(progressUpdates, progress)

            // スキャン完了したら終了
            if progress.Status == ScanStatusCompleted || progress.Status == ScanStatusFailed {
                goto done
            }
        }
    }
done:

    // 進捗が段階的に更新されていることを確認
    hasIncremental := false
    for i := 1; i < len(progressUpdates); i++ {
        if progressUpdates[i].SessionsSynced > progressUpdates[i-1].SessionsSynced {
            hasIncremental = true
            break
        }
    }

    if !hasIncremental {
        t.Error("Expected incremental progress updates during scan")
    }
}
```

---

### Phase 4: 統合とビルド確認

**ビルドコマンド**:
```bash
go build ./cmd/server
```

**テスト実行**:
```bash
go test ./internal/db -v -run "TestSyncAllWithCallback|TestSyncAllWithNilCallback"
go test ./internal/scanner -v -run "TestScanManagerProgressUpdates"
```

---

## Critical Files（変更対象ファイル）

### 変更するファイル

1. **`internal/db/sync.go`**
   - `SyncProgressCallback` 型定義追加
   - `SyncProgressUpdate` 構造体追加
   - `SyncAllWithCallback()` 関数追加
   - `SyncAllWithLoggerAndCallback()` 関数追加
   - 既存の `SyncAll()` は `SyncAllWithCallback(db, p, nil)` に委譲

2. **`internal/scanner/manager.go`**
   - `runScan()` メソッド修正
   - `db.SyncAllWithCallback()` を使用
   - コールバックで `m.progress` をリアルタイム更新

### 新規作成するファイル

3. **`internal/db/sync_test.go`** （既存ファイルがあれば追記）
   - `TestSyncAllWithCallback`
   - `TestSyncAllWithNilCallback`

4. **`internal/scanner/manager_test.go`** （既存ファイルがあれば追記）
   - `TestScanManagerProgressUpdates`

---

## 実装の詳細

### 1. コールバック型の設計

```go
// SyncProgressCallback はスキャン中に進捗を報告するためのコールバック
type SyncProgressCallback func(progress SyncProgressUpdate)

// SyncProgressUpdate はスキャン中の増分進捗を表す
type SyncProgressUpdate struct {
    ProjectsProcessed int  // 処理済みプロジェクト数
    SessionsFound     int  // 発見したセッション数（累積）
    SessionsSynced    int  // 同期したセッション数（累積）
    ErrorCount        int  // エラー数（累積）
}
```

### 2. コールバック呼び出しのタイミング

`SyncAllWithLoggerAndCallback()` 内で：

```go
for i, projectName := range projectNames {
    syncResult, err := syncProjectInternalWithLogger(db, p, projectName, log)

    // 結果を集計
    result.ProjectsProcessed++
    result.SessionsFound += syncResult.SessionsFound
    result.SessionsSynced += syncResult.SessionsSynced
    // ...

    // コールバックで進捗報告（プロジェクト処理ごと）
    if callback != nil {
        callback(SyncProgressUpdate{
            ProjectsProcessed: result.ProjectsProcessed,
            SessionsFound:     result.SessionsFound,
            SessionsSynced:    result.SessionsSynced,
            ErrorCount:        result.ErrorCount,
        })
    }
}
```

### 3. ScanManager でのコールバック実装

```go
func (m *ScanManager) runScan(ctx context.Context) {
    defer m.wg.Done()

    // コールバック定義（進捗をリアルタイム更新）
    progressCallback := func(update db.SyncProgressUpdate) {
        m.mu.Lock()
        m.progress.ProjectsProcessed = update.ProjectsProcessed
        m.progress.SessionsFound = update.SessionsFound
        m.progress.SessionsSynced = update.SessionsSynced
        m.progress.ErrorCount = update.ErrorCount
        m.mu.Unlock()
    }

    // コールバック付きでスキャン実行
    result, err := db.SyncAllWithCallback(m.db, m.parser, progressCallback)

    // ... エラーハンドリングと完了処理
}
```

### 4. スレッドセーフティ

- `SyncProgressUpdate` は値型（コピー渡し）
- `ScanManager.mu` でロックして `m.progress` を更新
- `GetProgress()` は既に `RWMutex` で保護されている

---

## 期待される効果

### Before（現在）

```
初期化中...
0 / 0 セッション   ← スキャン開始から完了まで変化なし
```

### After（修正後）

```
初期化中...
123 / 500 セッション   ← プロジェクト処理ごとに更新
...
234 / 1000 セッション
...
500 / 1500 セッション  ← リアルタイムで増加
```

### メリット

1. **ユーザー体験向上**
   - 進捗が視覚的にわかる
   - 「0/0」で固まっているように見えない
   - スキャンが進行中であることが明確

2. **パフォーマンス影響なし**
   - コールバックはプロジェクト単位（数十〜数百回）
   - セッション単位ではないので、オーバーヘッドは軽微

3. **後方互換性維持**
   - 既存の `SyncAll()` はそのまま動作
   - 新しい `SyncAllWithCallback()` を追加するだけ

---

## 実装上の注意点

### 1. 既存機能への影響

- `SyncAll()` の既存テストは全て維持
- `SyncIncrementalは変更なし（コールバック不要）
- API エンドポイント `/api/scan/status` は変更なし

### 2. エラーハンドリング

- コールバック内でpanicが発生しても、スキャン全体は失敗させない
- `defer recover()` でハンドリング（必要に応じて）

### 3. テストでの考慮点

- モックコールバックで呼び出し回数を検証
- nilコールバックでもエラーにならないことを確認
- 進捗が単調増加することを確認

---

## 検証方法

### 1. ユニットテスト

```bash
# Sync層のテスト
go test ./internal/db -v -run "TestSyncAllWithCallback"

# ScanManager のテスト
go test ./internal/scanner -v -run "TestScanManagerProgressUpdates"
```

### 2. 統合テスト（ビルド＆起動）

```bash
# ビルド
go build ./cmd/server

# サーバー起動
./server

# ブラウザで http://localhost:8080 にアクセス
# 初期化中の進捗が 0/0 から変化することを確認
```

### 3. 確認ポイント

- [ ] 初期起動時、進捗が「0 / 0」から変化する
- [ ] プロジェクト処理ごとに数値が増加する
- [ ] スキャン完了後、正しい総数が表示される
- [ ] 既存のテストが全てパスする

---

## タイムライン

### Phase 1: DB層の拡張（約30分）
- コールバック型定義
- `SyncAllWithCallback()` 実装
- 既存 `SyncAll()` の委譲修正

### Phase 2: ScanManager修正（約20分）
- `runScan()` にコールバック実装
- スレッドセーフな進捗更新

### Phase 3: テスト実装（約40分）
- `TestSyncAllWithCallback`
- `TestSyncAllWithNilCallback`
- `TestScanManagerProgressUpdates`

### Phase 4: 統合テスト（約30分）
- ビルド確認
- ユニットテスト実行
- ローカル環境での動作確認

**合計**: 約2時間

---

## 将来的な拡張可能性

### より細かい進捗粒度

現在はプロジェクト単位でコールバック呼び出し。将来的にはセッション単位にも対応可能：

```go
// セッション単位の進捗報告
type SyncProgressUpdate struct {
    ProjectsProcessed int
    SessionsFound     int
    SessionsSynced    int
    ErrorCount        int
    CurrentProject    string  // 現在処理中のプロジェクト名
    CurrentSession    string  // 現在処理中のセッションID
}
```

ただし、セッション単位だとコールバック呼び出し回数が増加（数千〜数万回）するため、パフォーマンスへの影響を検証する必要がある。

---

## 関連ドキュメント

- **WIPドキュメント**: `docs/WIP/2026-01-25_スキャン最適化実装完了.md`
- **プロジェクトガイドライン**: `CLAUDE.md`
- **一般開発ルール**: `.claude/rules/general.md`
- **API設計**: `docs/API設計.md`
