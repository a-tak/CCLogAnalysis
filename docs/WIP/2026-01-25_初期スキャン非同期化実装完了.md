# 2026-01-25 初期スキャン非同期化実装完了

## 実装内容

### 目的

サーバー起動時の初期スキャンを非同期化し、大量のセッションファイルがある場合でもWebサーバーを即座に起動できるようにする。

### 実装結果

✅ **Phase 1: バックエンド基盤**
- `internal/scanner/manager.go` - スキャン状態管理マネージャー作成
- `internal/scanner/manager_test.go` - 単体テスト作成（全てパス）
- `cmd/server/main.go` - 非同期スキャン開始に変更
- `internal/api/service_db.go` - 重複スキャン防止（autoSyncIfNeeded無効化）

✅ **Phase 2: API実装**
- `internal/api/handlers_scan.go` - スキャン状態APIハンドラー
- `internal/api/router.go` - `/api/scan/status`エンドポイント追加
- `internal/api/types.go` - `ScanStatusResponse`型定義

✅ **Phase 3: フロントエンド実装**
- `web/src/lib/api/types.ts` - `ScanStatus`型追加
- `web/src/lib/api/client.ts` - `getScanStatus`メソッド追加
- `web/src/components/scan/ScanStatusIndicator.tsx` - スキャン進行中インジケーター
- `web/src/components/layout/Layout.tsx` - インジケーター組み込み

---

## 動作確認結果

### スキャン状態API

```bash
curl http://localhost:8080/api/scan/status
```

レスポンス例：
```json
{
  "status": "completed",
  "projectsProcessed": 105,
  "sessionsFound": 12788,
  "sessionsSynced": 1,
  "errorCount": 0,
  "startedAt": "2026-01-25T17:29:18+09:00",
  "completedAt": "2026-01-25T17:29:28+09:00"
}
```

### 確認項目

- ✅ サーバーが即座に起動（スキャン待機なし）
- ✅ スキャンがバックグラウンドで実行
- ✅ `/api/scan/status`でスキャン状態が取得できる
- ✅ ビルドエラーなし
- ✅ 全ての単体テストがパス

---

## 技術詳細

### ScanManager

**ファイル**: `internal/scanner/manager.go`

**主要な型**:
```go
type ScanStatus string

const (
    ScanStatusIdle      ScanStatus = "idle"
    ScanStatusRunning   ScanStatus = "running"
    ScanStatusCompleted ScanStatus = "completed"
    ScanStatusFailed    ScanStatus = "failed"
)

type ScanProgress struct {
    Status            ScanStatus
    ProjectsProcessed int
    SessionsFound     int
    SessionsSynced    int
    ErrorCount        int
    StartedAt         time.Time
    CompletedAt       *time.Time
    LastError         string
}
```

**主要なメソッド**:
- `StartInitialScan(ctx context.Context)` - 非同期でスキャン開始
- `GetProgress()` - スレッドセーフに進捗取得
- `Stop()` - Graceful Shutdownでスキャン停止

### 変更されたファイル

#### 1. cmd/server/main.go

**変更前**:
```go
// Perform initial sync on startup
result, err := db.SyncAll(database, p)  // ブロッキング
```

**変更後**:
```go
// Create scan manager
scanManager := scanner.NewScanManager(database, p)

// Start initial sync asynchronously
if err := scanManager.StartInitialScan(context.Background()); err != nil {
    log.Printf("Warning: Failed to start initial scan: %v", err)
}
fmt.Println("Initial sync started in background...")
```

#### 2. internal/api/service_db.go

**変更内容**:
- `NewDatabaseSessionService`から`autoSyncIfNeeded()`の呼び出しを削除
- 理由: ScanManagerで初期スキャンを管理するため、重複を避ける

#### 3. フロントエンド

**ScanStatusIndicator**:
- 2秒ごとにポーリング
- スキャン実行中（`status: 'running'`）の場合のみ表示
- スキャン完了後は自動的に非表示
- 画面右下に固定表示（`z-50`でヘッダーより上に表示）

---

## 既知の課題

### 現在の動作

初期スキャン非同期化は完了したが、**スキャン自体の速度は最適化されていない**。

#### 問題点

`internal/db/sync.go`の`SyncIncremental`関数（行129-134）:
```go
func SyncIncremental(db *DB, p *parser.Parser) (*SyncResult, error) {
    // SyncAllと同じだが、既存セッションはスキップする
    // 実装上、SyncAllが既に重複チェックを行っているため、同じ動作になる
    return SyncAll(db, p)
}
```

**毎回実行される処理**（時間がかかる）:
1. 全プロジェクトのディレクトリスキャン
2. 全セッションファイルのリスト化
3. 各セッションIDがDBに存在するかのチェック

**スキップされる処理**（2回目以降は実行されない）:
- 既存セッションのパース処理
- データベースへの保存

### 影響

大量のセッションファイル（例: 12,788セッション）がある場合、2回目以降のスキャンでも同じくらい時間がかかる。

---

## 次のステップ（第2段階）

### 目標

スキャン処理自体を最適化し、2回目以降のスキャン時間を大幅に短縮する。

### 実装案

#### 案1: ファイル更新日時チェック（推奨）

**概要**:
- 前回スキャン以降に更新されたファイルだけを対象にする
- ファイルシステムの`modTime`を利用

**実装方針**:
1. データベースに`last_scan_time`カラムを追加
2. `ListSessions`でファイルの更新日時をチェック
3. 更新されたファイルのみをパース

**メリット**:
- 実装が比較的シンプル
- 確実に新規・更新ファイルを検出できる
- ファイルシステムの情報を活用

**デメリット**:
- ファイルの更新日時が変更される可能性がある（まれ）

#### 案2: スキャン結果をキャッシュ

**概要**:
- 最後にスキャンした時刻を記録
- その後の差分だけをチェック

**実装方針**:
1. ScanManagerに`lastScanTime`を保持
2. スキャン時に前回以降の変更のみを検出

**メリット**:
- メモリ内で高速に判定可能

**デメリット**:
- サーバー再起動時に情報が失われる（DBに永続化が必要）

#### 案3: ディレクトリごとの最終更新日時を確認

**概要**:
- プロジェクトディレクトリの更新日時が変わってなければスキップ

**実装方針**:
1. プロジェクトディレクトリの`modTime`をチェック
2. 変更がなければプロジェクト全体をスキップ

**メリット**:
- 高速（ディレクトリの更新日時だけチェック）

**デメリット**:
- ファイル追加・変更があってもディレクトリの更新日時が変わらない場合がある
- 精度が低い

### 推奨実装

**案1: ファイル更新日時チェック**が最も現実的で確実。

---

## 実装計画（案1の詳細）

### 1. データベーススキーマ変更

**sessions テーブルに追加**:
```sql
ALTER TABLE sessions ADD COLUMN file_mod_time TEXT;
```

**projects テーブルに追加**:
```sql
ALTER TABLE projects ADD COLUMN last_scan_time TEXT;
```

### 2. パーサー修正

**internal/parser/parser.go**:
- `ListSessions`でファイルの更新日時を返すように変更
- または新しいメソッド`ListSessionsWithModTime`を追加

### 3. SyncIncremental 実装

**internal/db/sync.go**:
- `SyncIncremental`を独立した実装に変更
- プロジェクトの`last_scan_time`と比較
- セッションの`file_mod_time`と比較
- 新規・更新ファイルのみをパース

### 4. テスト

- `SyncIncremental`の単体テスト
- ファイル更新時の増分スキャンテスト
- 大量ファイルでのパフォーマンステスト

---

## 参考情報

### 関連ドキュメント

- プラン: `.claude/plans/2026-01-25_初期スキャン非同期化.md`
- プロジェクトガイドライン: `CLAUDE.md`
- 技術スタック: `docs/技術スタック.md`

### 関連ファイル

**バックエンド**:
- `internal/scanner/manager.go` - スキャン管理
- `internal/db/sync.go` - 同期処理（最適化対象）
- `internal/parser/parser.go` - ファイルスキャン

**フロントエンド**:
- `web/src/components/scan/ScanStatusIndicator.tsx` - UI表示

---

## まとめ

### 今回の成果

✅ 初期スキャン非同期化が完了
✅ Webサーバーの即座起動を実現
✅ スキャン状況の可視化を実装

### 残課題

❌ スキャン処理自体の最適化（2回目以降も同じ時間がかかる）

### 次のアクション

第2段階として、**ファイル更新日時チェック**によるスキャン最適化を実装する。
