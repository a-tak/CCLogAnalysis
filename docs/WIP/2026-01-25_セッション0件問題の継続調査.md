# セッション0件問題の継続調査

**日付**: 2026-01-25
**ブランチ**: `investigate-session-pickup-issue`
**状態**: 診断機能実装済み、根本原因未解決

## 問題の概要

フロントエンドのセッション一覧画面で、セッション数が **0件** と表示される問題が継続しています。

### 背景

- ファイルシステム上には66個のセッションファイル（`.jsonl`）が存在
- データベースには2852個のセッションが同期されている（診断エンドポイントで確認済み）
- しかし、フロントエンドでは0件と表示される

## これまでの作業

### 1. 診断機能の実装（完了）

以下の機能を実装して、問題の診断を可能にしました：

#### 実装したファイル

- `internal/logger/logger.go` - 構造化ログ機能
- `internal/logger/logger_test.go` - ログのテスト
- `internal/api/debug.go` - デバッグエンドポイント
- `internal/api/debug_test.go` - デバッグエンドポイントのテスト
- `internal/db/sync.go` - 詳細ログ追加、UNIQUE制約エラーハンドリング
- `internal/db/sync_test.go` - 同期処理のテスト

#### 診断エンドポイント

```bash
curl http://localhost:8081/api/debug/status
```

**期待される出力例**:

```json
{
  "db_projects": 105,
  "db_sessions": 2852,
  "fs_projects": 105,
  "sync_status": "success",
  "sync_error": ""
}
```

### 2. エラーハンドリング改善（完了）

- `ListSessions` でプロジェクトが見つからない場合、警告ログを出力するように変更
- UNIQUE制約エラーを検出して、重複セッションをスキップ（WARNレベル）
- `SyncResult` にエラー詳細（`Errors []string`）を追加

### 3. mainブランチのマージ（完了）

以下の機能がmainブランチから統合されました：

- Git Root検出機能
- プロジェクトグループ機能
- プロジェクト詳細・グループ詳細ページ
- セッションリストタブ

### 4. サーバー管理スクリプト実装（完了）

- `.claude/skills/server-management/scripts/start-server.sh` - サーバー起動
- `.claude/skills/server-management/scripts/stop-server.sh` - サーバー停止

**現在のサーバー状態**:

- URL: <http://localhost:8081>
- ログレベル: DEBUG
- 起動中

## 現在の状況

### 確認済みの事実

1. **データベースには正しくデータが入っている**
   - 105プロジェクト
   - 2852セッション

2. **初期同期は成功している**
   - `sync_status: "success"`
   - エラーなし

3. **フロントエンドでセッション一覧を開くと0件**
   - プロジェクト一覧は表示される
   - セッション一覧タブに切り替えても0件

### 未確認の可能性

- **APIリクエストが正しく動作していない可能性**
  - フロントエンドからのAPIリクエストパラメータが間違っている？
  - レスポンスが空配列になっている？

- **フロントエンドのデータ取得ロジックに問題がある可能性**
  - APIクライアントの実装に問題？
  - 状態管理の問題？

- **バックエンドのListSessionsエンドポイントに問題がある可能性**
  - プロジェクト名のフィルタリングが機能していない？
  - レスポンス形式が間違っている？

## 次のステップ

### 1. APIリクエストの確認（最優先）

ブラウザの開発者ツールで以下を確認：

```bash
# ブラウザでアクセス
http://localhost:8081

# 開発者ツール（F12） > Network タブ
# セッション一覧を開いた時のリクエストを確認：
# - GET /api/sessions?project=xxx
# - レスポンスボディの内容
# - ステータスコード
```

### 2. バックエンドのログ確認

サーバーのログファイルを確認して、リクエストが到達しているか確認：

```bash
tail -f .claude/skills/server-management/server.log
```

期待されるログ：

- `ListSessions` が呼ばれている
- プロジェクト名が正しく渡されている
- データベースクエリが実行されている

### 3. 直接APIを叩いて確認

curlでバックエンドAPIを直接テスト：

```bash
# プロジェクト一覧を取得
curl http://localhost:8081/api/projects

# 特定プロジェクトのセッション一覧を取得
# ⚠️ プロジェクト名はエンコードされている可能性があるので注意
curl "http://localhost:8081/api/sessions?project=-Users-{username}-Documents-GitHub-CCLogAnalysis"

# または全セッション
curl http://localhost:8081/api/sessions
```

### 4. フロントエンドのコード確認

以下のファイルを確認：

- `web/src/lib/api/client.ts` - API クライアントの実装
- `web/src/lib/api/types.ts` - レスポンス型定義
- `web/src/components/sessions/SessionListTab.tsx` - セッション一覧の表示ロジック
- `web/src/pages/ProjectsPage.tsx` - プロジェクトページの実装

特に確認すべきポイント：

- `listSessions` 関数のパラメータ
- プロジェクト名のエンコーディング
- エラーハンドリング

### 5. デバッグログの追加

必要に応じて、以下の箇所にデバッグログを追加：

**バックエンド** (`internal/api/handlers.go` の `listSessionsHandler`):

```go
log.InfoWithContext("ListSessions called", map[string]interface{}{
    "project": projectName,
})

// ... セッション取得後
log.InfoWithContext("Sessions retrieved", map[string]interface{}{
    "count": len(sessions),
})
```

**フロントエンド** (`web/src/lib/api/client.ts`):

```typescript
console.log('Fetching sessions for project:', project);
// ... レスポンス受信後
console.log('Received sessions:', data);
```

## 重要なファイル

### バックエンド

- `internal/api/router.go` - ルーティング設定
- `internal/api/service_db.go` - ListSessions の実装
- `internal/db/sessions.go` - データベースクエリ

### フロントエンド

- `web/src/lib/api/client.ts` - API クライアント
- `web/src/components/sessions/SessionListTab.tsx` - セッション一覧UI

### 診断

- `internal/api/debug.go` - デバッグエンドポイント
- `.claude/skills/server-management/server.log` - サーバーログ

## 期待される結果

問題を特定して修正した後、以下のようになるべき：

1. フロントエンドのセッション一覧に、データベース内のセッションが正しく表示される
2. プロジェクトでフィルタリングした場合、そのプロジェクトのセッションのみ表示される
3. セッション数が正しくカウントされる

## 参考情報

### プロジェクト構成

```
CCLogAnalysis/
├── cmd/server/           # サーバーエントリポイント
├── internal/
│   ├── api/             # REST API実装
│   ├── db/              # データベース層
│   ├── logger/          # ログ機能
│   └── parser/          # ログパーサー
├── web/                 # Reactフロントエンド
│   ├── src/
│   │   ├── lib/api/    # APIクライアント
│   │   ├── components/ # Reactコンポーネント
│   │   └── pages/      # ページコンポーネント
└── .claude/
    └── skills/
        └── server-management/ # サーバー管理スクリプト
```

### コミット履歴

最新のコミット：
1. `8d5e630` - fix: サーバー管理スクリプトとフロントエンドの型エラーを修正
2. `a4697f5` - Merge branch 'main' into investigate-session-pickup-issue
3. 前回のコミット群 - 診断機能実装、エラーハンドリング改善

## ✅ 根本原因を特定しました！（2026-01-25 13:40）

### 問題の原因

**log_entries.uuid のUNIQUE制約が厳しすぎる**

現在のスキーマ：
```sql
CREATE TABLE log_entries (
    ...
    uuid TEXT NOT NULL UNIQUE,  -- ← ここが問題！
    ...
);
```

#### なぜ問題なのか

1. **UUIDはグローバルにユニークである必要はない**
   - UUIDはあくまで「そのセッション内」でログエントリを識別するもの
   - 異なるセッションで同じUUIDが使われる可能性がある（リトライ、リプレイなど）

2. **UNIQUE制約エラーで全セッションが登録失敗**
   - GetSessionでは「見つからない」と判定される（まだDBに登録されていない）
   - ParseSession成功
   - CreateSession→トランザクション開始
   - sessions テーブルにINSERT成功
   - log_entriesテーブルにINSERT→**UNIQUE制約エラー**
   - トランザクションロールバック→セッションは登録されない
   - 次のプロジェクトでも同じ流れで失敗
   - 結果：**0 sessions synced**

#### ログから確認できたエラー

```
[2026-01-25 13:39:41] WARN: Session already exists (duplicate), skipping
  error_message=failed to insert log entry : UNIQUE constraint failed: log_entries.uuid
```

### 解決策

**log_entries.uuid のUNIQUE制約を複合UNIQUE制約に変更する**

#### 修正内容

1. **スキーマ定義の修正**（`internal/db/db.go`）

変更前：
```sql
CREATE TABLE log_entries (
    ...
    uuid TEXT NOT NULL UNIQUE,
    ...
);
```

変更後：
```sql
CREATE TABLE log_entries (
    ...
    uuid TEXT NOT NULL,
    ...
    UNIQUE(session_id, uuid)  -- 複合UNIQUE制約を追加
);
```

2. **データベースの再作成**
   - 既存のデータベースファイルを削除
   - サーバー再起動で新しいスキーマで作成される

#### 期待される結果

- セッション内でUUIDがユニークであることは保証される
- 異なるセッションで同じUUIDを使用してもエラーにならない
- 全セッションが正常に同期される
- フロントエンドでセッション一覧が表示される

## 実装済みの改善（2026-01-25）

### 1. 初回同期の追加 ✅

**ファイル**: `cmd/server/main.go`

```go
// Perform initial sync on startup
fmt.Println("Performing initial sync...")
result, err := db.SyncAll(database, p)
if err != nil {
    log.Printf("Warning: Initial sync failed: %v", err)
} else {
    fmt.Printf("Initial sync completed: %d projects, %d sessions synced\n",
        result.ProjectsProcessed, result.SessionsSynced)
}
```

### 2. 手動同期エンドポイントの追加 ✅

**ファイル**: `internal/api/debug.go`, `internal/api/router.go`

```bash
# 手動同期を実行
curl -X POST http://localhost:8081/api/debug/sync
```

### 3. 詳細ログの追加 ✅

**ファイル**: `internal/db/sync.go`

- GetSession結果のログ追加
- パース開始・DB保存開始のログ追加
- エラーメッセージの詳細化

## 次のセッションでやること

### 必須タスク

1. **スキーマ修正**
   - `internal/db/db.go` の `createTables` 関数を修正
   - `uuid TEXT NOT NULL UNIQUE` → `uuid TEXT NOT NULL` + `UNIQUE(session_id, uuid)`

2. **データベース再作成**
   ```bash
   # サーバー停止
   cat .claude/skills/server-management/.server.pid | cut -d: -f1 | xargs kill

   # データベース削除
   rm ccloganalysis.db

   # サーバー再起動
   .claude/skills/server-management/scripts/start-server.sh dev
   ```

3. **動作確認**
   - ブラウザで http://localhost:8081/groups/3 を開く
   - セッション数が0件でないことを確認
   - セッション一覧が正しく表示されることを確認

### オプショナルタスク

1. **sessions.id のUNIQUE制約も確認**
   - 同様の問題がないか検証

2. **テストの追加**
   - 同じUUIDを持つ異なるセッションを登録できることを確認するテスト

## ✅ 問題解決！（2026-01-25 14:00）

### 最終的な根本原因

**UUID が空のエントリ（`file-history-snapshot` など）が複数回INSERTされ、UNIQUE制約エラーが発生していた**

#### 詳細な原因

1. **log_entries.uuid の UNIQUE 制約が厳しすぎた**
   - 当初のスキーマ: `uuid TEXT NOT NULL UNIQUE`
   - 異なるセッション間でのUUID重複を想定していたが、実際は同じセッション内で重複していた

2. **UUID が null のエントリが問題だった**
   - `file-history-snapshot` タイプのエントリでは UUID が null
   - JSONパースで空文字列 `""` になる
   - 同じセッション内で複数の空文字列UUIDが挿入される
   - UNIQUE制約エラー発生

3. **初回同期のタイムアウト**
   - 大量のプロジェクト（voxment含む）を同期しようとして30秒でタイムアウト
   - サーバーがヘルスチェックに応答できない

### 実施した修正

#### 1. スキーマ修正（`internal/db/schema.sql`）

```sql
-- 修正前
uuid TEXT NOT NULL UNIQUE,

-- 修正後
uuid TEXT NOT NULL,
...
UNIQUE(session_id, uuid),  -- 複合UNIQUE制約を追加
```

#### 2. UUID が空のエントリをスキップ（`internal/db/sessions.go`）

```go
for _, entry := range session.Entries {
    // UUID が空のエントリはスキップ（file-history-snapshot など）
    if entry.UUID == "" {
        continue
    }

    result, err := logStmt.Exec(...)
    ...
}
```

#### 3. 初回同期を環境変数で制御（`cmd/server/main.go`）

```go
// Perform initial sync on startup (unless SKIP_INITIAL_SYNC is set)
skipInitialSync := os.Getenv("SKIP_INITIAL_SYNC") != ""
if !skipInitialSync {
    fmt.Println("Performing initial sync...")
    result, err := db.SyncAll(database, p)
    ...
} else {
    fmt.Println("Skipping initial sync (SKIP_INITIAL_SYNC is set)")
}
```

#### 4. 起動スクリプト修正（`.claude/skills/server-management/scripts/start-server.sh`）

```bash
case "$MODE" in
    dev)
        export LOG_LEVEL="DEBUG"
        export SKIP_INITIAL_SYNC="1"
        echo "🔧 開発モード(LOG_LEVEL=DEBUG, 初回同期スキップ)でサーバーを起動します..."
        ;;
    ...
esac
```

### 結果

- **データベース**: 6617セッションが正常に登録
- **API**: セッション一覧が正しく取得できる
- **フロントエンド**: セッション数が正しく表示される（0件問題が解決）
- **エラー**: 0件

### 動作確認

```bash
# サーバー起動
.claude/skills/server-management/scripts/start-server.sh dev

# 手動同期（必要に応じて）
curl -X POST http://localhost:8081/api/debug/sync

# ステータス確認
curl http://localhost:8081/api/debug/status
# => {"db_projects":105,"db_sessions":6617,"fs_projects":105,"sync_status":"success"}

# セッション一覧取得
curl "http://localhost:8081/api/sessions?limit=3"

# フロントエンドでアクセス
# http://localhost:8081/groups/2
```

## 注意事項

- サーバーは http://localhost:8081 で起動中
- LOG_LEVEL=DEBUG で詳細ログが出力される
- devモードでは初回同期をスキップ（`SKIP_INITIAL_SYNC=1`）
- 手動同期が必要な場合は `/api/debug/sync` を使用
- プロジェクト名はURLエンコードされている可能性がある（例: スラッシュが `-` に変換）
- ワークツリー環境なので、同じセッションが複数のプロジェクトで見つかる可能性がある
