# セッションリストのパフォーマンス改善

**作成日**: 2026-01-24
**ステータス**: 課題整理・設計中

---

## 問題

セッションリスト表示が非常に遅い。特に大量のセッション（757件など）を持つプロジェクトで顕著。

### 具体的な症状
- プロジェクトを開くのに時間がかかる
- セッションリストの表示に時間がかかる

---

## 原因分析

### 推測される原因

現在の実装では、`ListSessions()`クエリで**毎回セッション内部のメッセージを複雑に処理している**。

#### 現在のクエリ構造（`internal/db/sessions.go:354-397`）

```sql
SELECT s.id, ...,
       COALESCE(
           (SELECT SUBSTR(
               CASE
                   WHEN first_user.content_text = 'Warmup' AND second_user.content_text IS NOT NULL
                   THEN second_user.content_text
                   WHEN first_user.content_text = 'Warmup' AND second_user.content_text IS NULL AND first_assistant.content_text IS NOT NULL
                   THEN first_assistant.content_text
                   ELSE first_user.content_text
               END, 1, 100)
            FROM (
                -- 1番目のユーザーメッセージ取得
                SELECT m.content_text, ROW_NUMBER() OVER (ORDER BY le.timestamp ASC) as rn
                FROM log_entries le
                JOIN messages m ON le.id = m.log_entry_id
                WHERE le.session_id = s.id AND le.entry_type = 'user' AND m.role = 'user'
            ) first_user
            LEFT JOIN (
                -- 2番目のユーザーメッセージ取得
                SELECT m.content_text, ROW_NUMBER() OVER (ORDER BY le.timestamp ASC) as rn
                FROM log_entries le
                JOIN messages m ON le.id = m.log_entry_id
                WHERE le.session_id = s.id AND le.entry_type = 'user' AND m.role = 'user'
            ) second_user ON second_user.rn = 2
            LEFT JOIN (
                -- 1番目のアシスタントメッセージ取得
                SELECT m.content_text, ROW_NUMBER() OVER (ORDER BY le.timestamp ASC) as rn
                FROM log_entries le
                JOIN messages m ON le.id = m.log_entry_id
                WHERE le.session_id = s.id AND le.entry_type = 'assistant' AND m.role = 'assistant'
            ) first_assistant ON first_assistant.rn = 1
            WHERE first_user.rn = 1),
           ''
       ) as first_user_message
FROM sessions s
```

### パフォーマンス問題の詳細

1. **セッションごとに3つのサブクエリを実行**
   - 1番目のユーザーメッセージ
   - 2番目のユーザーメッセージ
   - 1番目のアシスタントメッセージ

2. **テーブルジョイン・スキャンが頻繁**
   - 各サブクエリで `log_entries` と `messages` をJOIN
   - `ROW_NUMBER()` ウィンドウ関数の実行

3. **スケーラビリティの問題**
   - 757セッション × 3サブクエリ = 最大2,271のサブクエリ実行
   - セッション数が増えるほど遅延が顕著に

---

## 提案される解決策

### アプローチ：事前計算 + DB格納

**毎回計算するのではなく、初回（セッション作成時）に計算してDBに格納する**

#### メリット
- リスト表示時のクエリが単純化（サブクエリ不要）
- 表示速度が劇的に向上
- スケーラビリティ向上

#### デメリット
- データの二重管理（`log_entries`/`messages` + `sessions.first_user_message`）
- セッション作成時の処理が若干増加（ただし1回だけ）

---

## 実装設計

### 1. スキーマ変更

**`sessions`テーブルに`first_user_message`カラムを追加**

```sql
ALTER TABLE sessions ADD COLUMN first_user_message TEXT DEFAULT '';
```

- 型: `TEXT`
- デフォルト: 空文字列
- 100文字に切り詰めて格納

### 2. `CreateSession()`の修正

**`internal/db/sessions.go`の`CreateSession()`関数**

セッション挿入前に、`first_user_message`を計算：

```go
func (db *DB) CreateSession(session *parser.Session, projectName string) error {
    // ... existing code ...

    // First user messageを計算
    firstUserMessage := calculateFirstUserMessage(session)

    sessionQuery := `
        INSERT INTO sessions (
            id, project_id, git_branch, start_time, end_time, duration_seconds,
            total_input_tokens, total_output_tokens,
            total_cache_creation_tokens, total_cache_read_tokens,
            error_count, first_user_message  // 追加
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `
    _, err = tx.Exec(sessionQuery,
        session.ID, projectID, session.GitBranch,
        session.StartTime, session.EndTime, durationSeconds,
        session.TotalTokens.InputTokens, session.TotalTokens.OutputTokens,
        session.TotalTokens.CacheCreationInputTokens, session.TotalTokens.CacheReadInputTokens,
        session.ErrorCount,
        firstUserMessage, // 追加
    )
    // ...
}
```

### 3. `calculateFirstUserMessage()`関数の実装

```go
func calculateFirstUserMessage(session *parser.Session) string {
    var firstUserMsg, secondUserMsg, firstAssistantMsg string

    userMsgCount := 0
    assistantMsgCount := 0

    for _, entry := range session.Entries {
        if entry.Type == "user" && entry.Message != nil {
            userMsgCount++
            if userMsgCount == 1 {
                firstUserMsg = extractTextFromContent(entry.Message.Content)
            } else if userMsgCount == 2 {
                secondUserMsg = extractTextFromContent(entry.Message.Content)
            }
        }

        if entry.Type == "assistant" && entry.Message != nil && assistantMsgCount == 0 {
            assistantMsgCount++
            firstAssistantMsg = extractTextFromContent(entry.Message.Content)
        }

        // 必要な情報が揃ったら早期終了
        if userMsgCount >= 2 && assistantMsgCount >= 1 {
            break
        }
    }

    // Warmup処理ロジック
    if firstUserMsg == "Warmup" {
        if secondUserMsg != "" {
            return truncate(secondUserMsg, 100)
        } else if firstAssistantMsg != "" {
            return truncate(firstAssistantMsg, 100)
        }
    }

    return truncate(firstUserMsg, 100)
}

func truncate(s string, maxLen int) string {
    if len(s) <= maxLen {
        return s
    }
    return s[:maxLen]
}
```

### 4. `ListSessions()`の簡素化

**サブクエリを削除し、カラムを直接SELECT**

```sql
SELECT s.id, s.project_id, s.git_branch, s.start_time, s.end_time, s.duration_seconds,
       s.total_input_tokens, s.total_output_tokens,
       s.total_cache_creation_tokens, s.total_cache_read_tokens,
       s.error_count,
       s.first_user_message,  -- 直接SELECT
       s.created_at, s.updated_at
FROM sessions s
```

---

## マイグレーション戦略

### 既存データの対応

既存のセッションには`first_user_message`が空なので、マイグレーションスクリプトが必要：

```go
func (db *DB) MigrateFirstUserMessages() error {
    // 全セッション取得
    rows, err := db.conn.Query("SELECT id FROM sessions WHERE first_user_message = ''")
    if err != nil {
        return err
    }
    defer rows.Close()

    for rows.Next() {
        var sessionID string
        rows.Scan(&sessionID)

        // セッション詳細取得
        session, err := db.GetSession(sessionID)
        if err != nil {
            log.Printf("Warning: failed to get session %s: %v", sessionID, err)
            continue
        }

        // First user message計算
        firstUserMessage := calculateFirstUserMessage(session)

        // 更新
        _, err = db.conn.Exec(
            "UPDATE sessions SET first_user_message = ? WHERE id = ?",
            firstUserMessage, sessionID,
        )
        if err != nil {
            log.Printf("Warning: failed to update session %s: %v", sessionID, err)
        }
    }

    return nil
}
```

---

## テスト戦略

### 1. ユニットテスト

- `calculateFirstUserMessage()`の各ケース
  - Warmup以外の通常メッセージ
  - Warmup + 2番目のユーザーメッセージ
  - Warmup + アシスタント応答のみ
  - 100文字超の切り詰め

### 2. 統合テスト

- `CreateSession()`で`first_user_message`が正しく保存されるか
- マイグレーション後の既存セッションの検証

### 3. パフォーマンステスト

- 改善前後のリスト表示速度を計測
- 757セッションでの実行時間比較

---

## 期待される改善効果

### パフォーマンス

- **改善前**: 約2秒（757セッション）
- **改善後（予測）**: 0.5秒未満

### クエリ複雑度

- **改善前**: O(n × 3) サブクエリ（nはセッション数）
- **改善後**: O(1) シンプルなSELECT

---

## 実装の優先順位

1. **Phase 1**: スキーマ変更 + `CreateSession()`修正（新規セッションで有効化）
2. **Phase 2**: `ListSessions()`簡素化（新規セッションで動作確認）
3. **Phase 3**: マイグレーションスクリプト実装（既存データ対応）
4. **Phase 4**: テスト追加 + パフォーマンス計測

---

## 関連ファイル

- `internal/db/sessions.go` - CreateSession(), ListSessions()
- `internal/db/migrations.go` - マイグレーションスクリプト（新規作成）
- `internal/db/schema.sql` - スキーマ定義
- `internal/db/sessions_test.go` - テストケース追加

---

## 備考

- 現在の実装でも機能は正常に動作している
- この改善は**パフォーマンス最適化**が目的
- 二重管理によるデータ不整合のリスクは低い（セッションは作成後に変更されない）
